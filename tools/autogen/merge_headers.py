#!/usr/bin/env python3

import os
import re
import sys
import argparse
import fnmatch
from collections import defaultdict, deque

def parse_include(line):
    """Extract the header path from an include directive."""
    match = re.match(r'#\s*include\s*([<"]([^>"]+)[>"])', line)
    if match:
        return match.group(1), match.group(2)
    return None, None

def glob_to_regex(pattern):
    """Convert a shell-style glob pattern to a regex pattern."""
    return fnmatch.translate(pattern)

def find_all_headers(directory, exclude_patterns=None):
    """Find all C/C++ header files in the given directory and subdirectories."""
    headers = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(('.h', '.hpp', '.hxx', '.h++', '.hh')):
                file_path = os.path.join(root, file)
                file_name = os.path.basename(file_path)
                
                # Check against exclude patterns
                if exclude_patterns:
                    excluded = False
                    for pattern in exclude_patterns:
                        # Try matching against full path
                        if re.search(pattern, file_path):
                            excluded = True
                            break
                        # Also try matching against just the filename
                        if re.search(pattern, file_name):
                            excluded = True
                            break
                    if excluded:
                        continue
                        
                headers.append(file_path)
    return headers

def build_dependency_graph(headers, directory):
    """Build a dependency graph of the headers."""
    # Create lookup by filename for easier matching with includes
    header_by_name = {}
    for h in headers:
        filename = os.path.basename(h)
        header_by_name[filename] = h
    
    # Build the graph
    graph = defaultdict(list)
    for header_path in headers:
        with open(header_path, 'r', errors='ignore') as f:
            for line in f:
                line_stripped = line.strip()
                if line_stripped.startswith('#include'):
                    _, include_path = parse_include(line_stripped)
                    if include_path:
                        include_filename = os.path.basename(include_path)
                        if include_filename in header_by_name:
                            graph[header_path].append(header_by_name[include_filename])
    
    return graph

def topological_sort(graph, headers):
    """Sort headers in topological order to resolve dependencies."""
    # Count incoming edges
    in_degree = {node: 0 for node in headers}
    for node in graph:
        for neighbor in graph[node]:
            in_degree[neighbor] = in_degree.get(neighbor, 0) + 1
    
    # Start with nodes that have no dependencies
    queue = deque([node for node in headers if in_degree[node] == 0])
    sorted_nodes = []
    
    while queue:
        node = queue.popleft()
        sorted_nodes.append(node)
        
        for neighbor in graph.get(node, []):
            in_degree[neighbor] -= 1
            if in_degree[neighbor] == 0:
                queue.append(neighbor)
    
    # Check for cycles
    if len(sorted_nodes) != len(headers):
        sys.stderr.write("Error: Circular dependencies detected in headers\n")
        return []
    
    # Return in reverse order (dependencies first)
    return sorted_nodes[::-1]

def is_project_include(include_path, include_filename, header_filenames, include_dirs):
    """Check if an include is part of our project's headers."""
    # Check if the basename is in our known headers
    if include_filename in header_filenames:
        return True
        
    # Check if the full path (using include_dirs) matches a header we have
    for include_dir in include_dirs:
        full_path = os.path.normpath(os.path.join(include_dir, include_path))
        if os.path.exists(full_path) and os.path.basename(full_path) in header_filenames:
            return True
            
    return False

def merge_headers(headers, output_file, directory, all_header_files, include_dirs):
    """Merge headers, preserving formatting, comments, and external includes."""
    # Track processed headers to avoid duplicates
    processed_headers = set()
    
    # Create set of header filenames for quick lookup
    header_filenames = {os.path.basename(h) for h in all_header_files}
    
    with open(output_file, 'w') as out:
        cmd = "python3"
        for arg in sys.argv:
            cmd += f" {arg}"
        out.write(f'// Merged header file - auto-generated by {cmd}\n\n')
        
        for header in headers:
            if header in processed_headers:
                continue
                
            processed_headers.add(header)
            rel_path = os.path.relpath(header, directory)
            out.write(f'// Begin content from: {rel_path}\n')
            
            with open(header, 'r', errors='ignore') as f:
                for line in f:
                    line_stripped = line.strip()
                    
                    # Handle include directives
                    if line_stripped.startswith('#include'):
                        include_directive, include_path = parse_include(line_stripped)
                        
                        if not include_directive or not include_path:
                            out.write(line)  # Keep unparseable include lines
                            continue
                            
                        include_filename = os.path.basename(include_path)
                        
                        # Check if this is a project include that will be merged
                        if is_project_include(include_path, include_filename, header_filenames, include_dirs):
                            indent = line[:len(line) - len(line.lstrip())]
                            out.write(f"{indent}// {line.lstrip()}")  # Comment out project include
                        else:
                            out.write(line)  # Keep external includes
                    
                    # Skip pragma once but keep everything else
                    elif not line_stripped.startswith('#pragma once'):
                        out.write(line)  # Keep original formatting
            
            out.write(f'// End content from: {rel_path}\n\n')

def main():
    parser = argparse.ArgumentParser(description='Merge C/C++ header files into a single header file.')
    parser.add_argument('directory', help='Directory containing header files to merge')
    parser.add_argument('-o', '--output', default='./merged.h', help='Output file path (default: ./merged.h)')
    parser.add_argument('-e', '--exclude', action='append', help='Pattern to exclude header files (can be used multiple times, supports glob patterns like *.hpp)')
    parser.add_argument('-I', '--include-dir', action='append', dest='include_dirs', 
                      help='Additional include directories to search for headers (can be used multiple times, e.g., -I /usr/include)')
    
    args = parser.parse_args()
    
    directory = os.path.abspath(args.directory)
    output_file = os.path.abspath(args.output)
    include_dirs = [os.path.abspath(d) for d in args.include_dirs] if args.include_dirs else []
    
    if include_dirs:
        print(f"Using include directories: {', '.join(include_dirs)}")
    # Add the main directory to include_dirs
    include_dirs.append(directory)
    
    # Convert exclude patterns to regex
    exclude_patterns = None
    if args.exclude:
        exclude_patterns = [glob_to_regex(pattern) for pattern in args.exclude]
        print(f"Excluded files matching patterns: {', '.join(args.exclude)}")
    
    if not os.path.isdir(directory):
        sys.stderr.write(f"Error: {directory} is not a valid directory\n")
        sys.exit(1)
    
    print(f"Scanning for header files in {directory}...")
    all_header_files = find_all_headers(directory, exclude_patterns)
    
    if not all_header_files:
        sys.stderr.write(f"Error: No header files found in {directory}\n")
        sys.exit(1)
    
    print(f"Found {len(all_header_files)} header files: {', '.join(all_header_files)}")
    
    print("Building dependency graph...")
    graph = build_dependency_graph(all_header_files, directory)
    
    print("Sorting headers by dependencies...")
    sorted_headers = topological_sort(graph, all_header_files)
    
    if not sorted_headers:
        sys.exit(1)
    
    print(f"Merging headers to {output_file}...")
    merge_headers(sorted_headers, output_file, directory, all_header_files, include_dirs)
    
    print(f"Successfully merged {len(all_header_files)} headers to {output_file}")

if __name__ == "__main__":
    main()
